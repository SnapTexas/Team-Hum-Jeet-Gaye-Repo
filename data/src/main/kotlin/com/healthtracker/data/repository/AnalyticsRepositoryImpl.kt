package com.healthtracker.data.repository

import com.healthtracker.domain.model.DailyAnalytics
import com.healthtracker.domain.model.DataPoint
import com.healthtracker.domain.model.GoalProgress
import com.healthtracker.domain.model.HealthMetrics
import com.healthtracker.domain.model.Insight
import com.healthtracker.domain.model.MetricAverages
import com.healthtracker.domain.model.MetricType
import com.healthtracker.domain.model.MonthlyAnalytics
import com.healthtracker.domain.model.TrendAnalysis
import com.healthtracker.domain.model.TrendDirection
import com.healthtracker.domain.model.WeeklyAnalytics
import com.healthtracker.domain.repository.AnalyticsRepository
import com.healthtracker.domain.repository.HealthDataRepository
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import java.time.DayOfWeek
import java.time.LocalDate
import java.time.YearMonth
import java.time.temporal.TemporalAdjusters
import javax.inject.Inject

/**
 * Implementation of AnalyticsRepository.
 * Delegates to HealthDataRepository for data retrieval and provides analytics transformations.
 */
class AnalyticsRepositoryImpl @Inject constructor(
    private val healthDataRepository: HealthDataRepository
) : AnalyticsRepository {
    
    override fun getDailyAnalytics(date: LocalDate): Flow<DailyAnalytics> {
        return healthDataRepository.getHealthMetrics(date).map { metrics ->
            DailyAnalytics(
                date = date,
                metrics = metrics,
                insights = emptyList(), // Insights generated by use case
                goalProgress = emptyList() // Goal progress calculated by use case
            )
        }
    }
    
    override fun getWeeklyAnalytics(weekStart: LocalDate): Flow<WeeklyAnalytics> {
        val weekEnd = weekStart.plusDays(6)
        return healthDataRepository.getHealthMetricsRange(weekStart, weekEnd).map { metricsList ->
            WeeklyAnalytics(
                weekStart = weekStart,
                dailyMetrics = metricsList,
                averages = calculateAverages(metricsList),
                trends = emptyList(), // Trends calculated by use case
                insights = emptyList() // Insights generated by use case
            )
        }
    }
    
    override fun getMonthlyAnalytics(month: YearMonth): Flow<MonthlyAnalytics> {
        val monthStart = month.atDay(1)
        val monthEnd = month.atEndOfMonth()
        
        return healthDataRepository.getHealthMetricsRange(monthStart, monthEnd).map { metricsList ->
            MonthlyAnalytics(
                month = month,
                weeklyData = emptyList(), // Weekly data grouped by use case
                monthlyAverages = calculateAverages(metricsList),
                trends = emptyList(), // Trends calculated by use case
                insights = emptyList() // Insights generated by use case
            )
        }
    }
    
    override fun getTrendAnalysis(metric: MetricType, days: Int): Flow<TrendAnalysis> {
        val endDate = LocalDate.now()
        val startDate = endDate.minusDays(days.toLong() - 1)
        
        return healthDataRepository.getHealthMetricsRange(startDate, endDate).map { metricsList ->
            val dataPoints = metricsList.map { metrics ->
                DataPoint(
                    date = metrics.date,
                    value = getMetricValue(metrics, metric)
                )
            }.sortedBy { it.date }
            
            val values = dataPoints.map { it.value }
            
            TrendAnalysis(
                metricType = metric,
                direction = calculateTrendDirection(values),
                percentageChange = calculatePercentageChange(values),
                dataPoints = dataPoints
            )
        }
    }
    
    private fun calculateAverages(metricsList: List<HealthMetrics>): MetricAverages {
        if (metricsList.isEmpty()) {
            return MetricAverages(
                averageSteps = 0.0,
                averageDistance = 0.0,
                averageCalories = 0.0,
                averageSleepMinutes = 0.0,
                averageScreenTimeMinutes = 0.0,
                averageHeartRate = null,
                averageHrv = null
            )
        }
        
        val count = metricsList.size.toDouble()
        
        val allHeartRateSamples = metricsList.flatMap { it.heartRateSamples }
        val avgHeartRate = if (allHeartRateSamples.isNotEmpty()) {
            allHeartRateSamples.map { it.bpm }.average()
        } else null
        
        val allHrvSamples = metricsList.flatMap { it.hrvSamples }
        val avgHrv = if (allHrvSamples.isNotEmpty()) {
            allHrvSamples.map { it.sdnn }.average()
        } else null
        
        return MetricAverages(
            averageSteps = metricsList.sumOf { it.steps } / count,
            averageDistance = metricsList.sumOf { it.distanceMeters } / count,
            averageCalories = metricsList.sumOf { it.caloriesBurned } / count,
            averageSleepMinutes = metricsList.sumOf { it.sleepDurationMinutes } / count,
            averageScreenTimeMinutes = metricsList.sumOf { it.screenTimeMinutes } / count,
            averageHeartRate = avgHeartRate,
            averageHrv = avgHrv
        )
    }
    
    private fun calculateTrendDirection(values: List<Double>): TrendDirection {
        if (values.size < 2) return TrendDirection.STABLE
        
        val firstHalf = values.take(values.size / 2)
        val secondHalf = values.drop(values.size / 2)
        
        val firstAvg = if (firstHalf.isNotEmpty()) firstHalf.average() else 0.0
        val secondAvg = if (secondHalf.isNotEmpty()) secondHalf.average() else 0.0
        
        val changePercent = if (firstAvg != 0.0) {
            ((secondAvg - firstAvg) / firstAvg) * 100
        } else 0.0
        
        return when {
            changePercent > 5 -> TrendDirection.INCREASING
            changePercent < -5 -> TrendDirection.DECREASING
            else -> TrendDirection.STABLE
        }
    }
    
    private fun calculatePercentageChange(values: List<Double>): Double {
        if (values.size < 2) return 0.0
        
        val first = values.first()
        val last = values.last()
        
        return if (first != 0.0) {
            ((last - first) / first) * 100
        } else 0.0
    }
    
    private fun getMetricValue(metrics: HealthMetrics, metricType: MetricType): Double {
        return when (metricType) {
            MetricType.STEPS -> metrics.steps.toDouble()
            MetricType.DISTANCE -> metrics.distanceMeters
            MetricType.CALORIES -> metrics.caloriesBurned
            MetricType.SCREEN_TIME -> metrics.screenTimeMinutes.toDouble()
            MetricType.SLEEP -> metrics.sleepDurationMinutes.toDouble()
            MetricType.HEART_RATE -> metrics.heartRateSamples.map { it.bpm }.average().takeIf { !it.isNaN() } ?: 0.0
            MetricType.HRV -> metrics.hrvSamples.map { it.sdnn }.average().takeIf { !it.isNaN() } ?: 0.0
            MetricType.MOOD -> metrics.mood?.ordinal?.toDouble() ?: 2.0
        }
    }
}
